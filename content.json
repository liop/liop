{"pages":[{"title":"","date":"2022-05-29T06:24:19.718Z","path":"test.js","text":"function Person(name) { var a = new Object(); a.name = name; a.say = function () { console.log(this.name) } a.__proto__ = Person.prototype; return a; }; let a = new Person('a'); console.log(a.__proto__) a.say();"},{"title":"关于我","date":"2020-03-09T04:48:15.000Z","path":"about/index.html","text":"联系我 (正在寻求前端&#x2F;全栈的开发工作，有岗位请联系我)邮箱: just.liop#qq.comgithub: liop 我的技术栈 精通 Object-C，熟悉 iOS 平台 熟悉 vue + vuex + webpack + element-ui 熟悉 react + react-router + webpack + antd 有 node.js 接口开发经验, 熟悉 mongodb、redis 熟悉 linux 平台，熟悉 CI&#x2F;CD, 熟悉 docker 我的个人项目BTSyncKeys为Resilio Sync 提供 key 的搜索，最新最热key排行 telegram 机器人 @image2image_bot 以图搜图机器人，调用的google图片搜索 @tozh_bot 翻译机器人，支持粤语 我的工作项目iOS保定通、 达州通、 银川通 （2018-2019） 保定通是中电信用携手保定市公交总公司在“智慧公交”理念基础上，合力打造的便民APP。为保定市民提供云卡充值、二维码乘车；公交路线查询；便民缴费等服务。倡导市民开启高效、低碳、环保出行的移动支付绿色时代。 钉铛 （2015-2018） 钉铛作为一款精准营销产品，承载运营商大数据平台，为企业电话销售提供精准的客户线索，帮助企业大幅提高客户转化率和营销效率。同时还支持通过手机进行批量呼叫，高效管理员工、客户的通话记录与录音；自动记录与客户的通话情况，与客户资料信息有效结合，帮助销售快速了解与客户的沟通情况和商机进展。 瑞钱宝 （2015） 瑞钱宝 为借款和出借双方实现投融资渠道的，已下架 PC端 统一通信-官网 统一通信-企业管理后台 移动端H5惠配通 中所有h5 (2020-2022) 惠配通是惠民网旗下面向超市老板的客户端，专门为社区超市经营管理者打造的线上订货APP,提供超市日常销售的食品、零食、粮油等生活必须的商品，充分利用互联网和电商平台的优势,解决社区超市进货难,进货贵,进假货的问题。线上订货、线下配送，为社区超市提供货品支持，提高了超市运营的效率。同时惠配通还会不断推出各种满额返利、限时特惠、新品特价等优惠促销活动，给用户满意的服务体验。 电信大数据风控 联调大数据营销 钉铛AI"},{"title":"categories","date":"2020-03-09T04:21:59.000Z","path":"categories/index.html","text":""},{"title":"tags","date":"2020-03-09T04:22:55.000Z","path":"tags/index.html","text":""}],"posts":[{"title":"移动端页面调试","date":"2021-01-25T02:37:21.000Z","path":"2021/01/25/移动端页面调试/","text":"最近遇到了很多移动端调试h5页面的坑，总结一下 安卓端调试h5一般情况下 安卓的包需要是开启webview调试 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true);&#125; 安卓设备需要打开开发者模式-运行远程调试 chrome浏览器打开 chrome://inspect, 勾选 usb调试 （Enable USB Debuggin） 如果打开白屏或者404需要等一会儿，让chrome下载对应移动端设备的dev-tools（可能需要翻墙） 特殊情况下 比如调试线上环境的包或者其他没有开启调试的包 和上面一般情况一样设置设备和chrome 安装 Xposed（root情况下）或者 VirtualXposed 在 Xposed 中安装 WebViewDebugHook[WebViewDebugHook] 在 Xposed 中安装 要调试的包 在 Xposed 模块管理启用 WebViewDebugHook, 然后重启一下 Xposed 现在可以连接设备， 打开h5页面 进行调试了 iOS 端调试h5一般情况下 iOS包要安装在手机上，需要是真机调试的包或者说是开发证书打的包，或者只是在模拟器上运行 连接手机，打开电脑上 safari-菜单-开发-对应的设备-对应的页面。如果没有看到开发菜单，需要在safari的首选项-高级中，勾选“在菜单栏中线上 开发 菜单” safari的调试工具不好用的话，可以试试 ios-webkit-debug-proxy 特殊情况下 比如调试线上环境的包或者其他没有开启调试的包 越狱环境: 直接安装 GlobalWebInspect, 重启要调试的应用，就能在 safari 中看见了 非越狱环境: MonkeyDev 砸壳、重打包 参考资料 VirtualXposed Xposed WebViewDebugHook GlobalWebInspect ios-webkit-debug-proxy iOS：Safari或Chrome调试Webview","tags":[{"name":"iOS 强制调试","slug":"iOS-强制调试","permalink":"http://liop.github.io/tags/iOS-%E5%BC%BA%E5%88%B6%E8%B0%83%E8%AF%95/"},{"name":"安卓 强制调试","slug":"安卓-强制调试","permalink":"http://liop.github.io/tags/%E5%AE%89%E5%8D%93-%E5%BC%BA%E5%88%B6%E8%B0%83%E8%AF%95/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://liop.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"dispath_once内部实现","date":"2020-05-10T06:39:42.000Z","path":"2020/05/10/dispath_once内部/","text":"dispath_oncedispatch_once 实际调用 dispatch_once_f void dispatch_once_f(dispatch_once_t *val, void *ctxt, void (*func)(void *))&#123; volatile long *vval = val; if (dispatch_atomic_cmpxchg(val, 0l, 1l)) &#123; func(ctxt); // block真正执行 dispatch_atomic_barrier(); *val = ~0l; &#125; else &#123; do &#123; _dispatch_hardware_pause(); &#125; while (*vval != ~0l); dispatch_atomic_barrier(); &#125;&#125; dispatch_atomic_cmpxchg 实际是 __sync_bool_compare_and_swap(p,o,n)， 这是LockFree给予CAS的一种原子操作机制，原理就是 如果p&#x3D;&#x3D;o，那么将p设置为n，然后返回true;否则，不做任何处理返回false","tags":[{"name":"技巧","slug":"技巧","permalink":"http://liop.github.io/tags/%E6%8A%80%E5%B7%A7/"}],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://liop.github.io/categories/iOS/"}]},{"title":"各种生命周期","date":"2020-05-08T11:15:49.000Z","path":"2020/05/08/生命周期/","text":"vue实例生命周期 [2.0] beforeCreate created beforeMount mounted beforeUpdate update beforeDestroy destroyed vue-router 生命周期 全局的 router.beforeEach router.beforeResolve router.afterEach 单个路由独享 beforeEnter 组件级的 beforeRouteEnter beforeRouteUpdate beforeRouteLeave 微信小程序 onLoad – 监听页面加载 onShow – 页面显示 onReady – 页面初次渲染完成 &#x2F;&#x2F; 进入后台 onHide – 页面隐藏 &#x2F;&#x2F; 进入前台 onShow – 页面显示 onUnload – 页面销毁 其他 onPullDownRefresh – 用户下来刷新 onReachBottom – 上拉刷新 onShareAppMessage – 点击右上角转发 onPageScroll – 页面滚动处理 onTabItemTap – 点击tab处理 iOS ViewController viewload viewDidLoad viewWillAppear viewWillLayoutSubviews viewDidLayoutSubviews viewDidAppear viewWillDisAppear viewDidDisApear AB页面切换时：A-&gt;B A viewWillDisApear B viewWillAppear A ViewDidDisApear B viewDidApear 参考资料 微信小程序页面的生命周期 实例生命周期钩子","tags":[{"name":"生命周期","slug":"生命周期","permalink":"http://liop.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://liop.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端缓存","date":"2020-05-07T03:40:01.000Z","path":"2020/05/07/前端缓存/","text":"性能优化总少不了缓存，网页性能优化里面静态资源相关优化是少不了浏览器的缓存 强缓存通过 两个http response header: Expires Cache-Control Expires: 浏览器请求时，会把资源和response header 都缓存下来 再次请求这个资源时，会先在缓存中找，如果找到了，而且当前时间小于Expires中的时间，缓存命中就不会去请求服务器了。所以首当前客户端时间影响 如果缓存没有命中会去请求服务器，更新Expires Cache-Control: 第一次请求时，会缓存资源和Response header 再次请求时，会先从缓存中找，找到后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。 如果缓存没有命中，会去请求服务器，然后更新本地 Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。 这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。 协商缓存通过两对http request&#x2F;response header: Etag&#x2F;If-None-Match Last-Modified&#x2F;If-Modified-Since Etag&#x2F;If-None-Match: 第一次请求，在ResponseHeader中返回服务器根据资源生成的 Etag 第二次请求时，requestHeader带上If-None-Match，值为Etag，服务器接受请求时根据资源生成Etag 和If-None-Match进行比较，如果相同，表示资源没有变化，返回 304 Not Modified，如果不同，表示资源变化了，返回新的资源 Last-Modified&#x2F;If-Modified-Since: 第一次请求，在ResponseHeader中返回服务器根据资源生成的 Last-Modified 第二次请求时，requestHeader带上If-Modified-Since，值为Last-Modified，服务器接受请求时根据资源的最后修改时间 和If-None-Match进行比较，如果相同，表示资源没有变化，返回 304 Not Modified，如果不同，表示资源变化了，返回新的资源 协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，这是为了处理Last-Modified不可靠的情况。 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败； 分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）； ServiceWorker 离线缓存Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤： 首先需要先注册 Service Worker 监听到 install 事件以后就可以缓存需要的文件 在下次用户访问的时候通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 一些疑问：Q：同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】的优先级？ A：Etag是因为Last-Modified的一些问题，比如文件头修改了，内容没有修改等，而出现的。Etag的优先级大于Last-Modified 参考资料 浏览器缓存知识小结及应用","tags":[{"name":"前端缓存","slug":"前端缓存","permalink":"http://liop.github.io/tags/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/"},{"name":"性能优化","slug":"性能优化","permalink":"http://liop.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://liop.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端错误监控","date":"2020-05-06T13:32:15.000Z","path":"2020/05/06/前端错误监控/","text":"看了[一步一步搭建前端监控系统] 觉得非常不错，记录总结一下 JS错误监控 重写window.onerror 方法，来处理异步的错误 重写console.error 方法,暂时没发现有什么用 重写window.onunhandlerejection,用于Promise出错，但是没有catch的时候 静态资源加载监控需要先加载监控的sdk才有用 通过window.onerror方法，跨域资源加载会有问题，需要设置&#96;&#96;crossorigin&#96;&#96;&#96;,参考MDN 利用performance.getEntries() 方法，能获取所有加载成功的资源列表，但是检查时机难掌握 通过window.addEventListener(&#39;error&#39;,cb)来捕获。 function cb(e) &#123; let type = e.target.localName; let sourceUrl = &#x27;&#x27;; if (type == &#x27;link&#x27;) &#123; // css sourceUrl = e.target.href; &#125; else if (type == &#x27;script&#x27;) // js sourceUrl = e.target.src; &#125; //todo: upload&#125; 接口请求监控前端请求用ajax、fetch,或者其他框架都是对 window.XMLHttpRequest的封装 对ajax请求，监听loadstart,loadend事件,因为事件的detail引用一样，所以能定位请求的开始和结束 对fetch请求，因为浏览器内置的，现在我们代码执行，所以需要重写一下 JS截屏和录屏 截屏：html2canvas 录屏：rrweb 写在最后引用MDN文档，window.onerror 和 window.addEventListener的区别： GlobalEventHandlers 的onerror属性是用于处理error事件的事件处理程序，错误事件在各种目标对象的不同类型错误被触发： 当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的error事件，并执行window.onerror()。 当一项资源（如&lt;img&gt;或&lt;script&gt;）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，不过（至少在Firefox中）能被单一的window.addEventListener捕获。 加载一个全局的error事件处理函数可用于自动收集错误报告。 参考资料 一步一步搭建前端监控系统 MDN GlobalEventHandlers","tags":[{"name":"错误监控","slug":"错误监控","permalink":"http://liop.github.io/tags/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://liop.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"JS的EventLoop和OC的RunLoop比较","date":"2020-05-04T10:16:55.000Z","path":"2020/05/04/各语言eventloop实现/","text":"在看JS面试题发现JS的eventloop 和OC中的Runloop结构类似，记录下 一、浏览器端JS的EventLoop示意图(来源 @nekron) 定义： 宏任务：主代码、setTimeout、setInterval 、UI交互事件 微任务：Promise 、mutation observer 流程： 执行一次task 执行微任务（MicrotaskQueue），直到队列清空 执行UI render（JS引擎线程被挂起等待，GUI渲染线程开始运行） 二、node环境的EventLoopnode整体结构示意图（来源：@ImNeutralChaos) node的EventLoop 示意图(来源 @nekron) Node的Event Loop分阶段，阶段有先后，依次是 expired timers and intervals，即到期的setTimeout&#x2F;setInterval I&#x2F;O events，包含文件，网络等等 immediates，通过setImmediate注册的函数 close handlers，close事件的回调，比如TCP连接断开 同步任务及每个阶段之后都会清空microtask队列 优先清空next tick queue，即通过- process.nextTick注册的函数 再清空other queue，常见的如Promise 而和规范的区别，在于node会清空当前所处阶段的队列，即执行所有task 三、OC的RunLoop示意图(来源：@ibireme) 定义： Observer: runloop 各阶段的事件监听 Source: source0 内部事件监听 source1 基于mach_Port的,外部事件监听 Timer：定时器 参考资料 Event Loop的规范和实现 结合JS运行机制，理解Event Loop 详解JavaScript中的Event Loop（事件循环）机制 JavaScript 运行机制详解：再谈Event Loop 深入理解RunLoop","tags":[{"name":"EventLoop","slug":"EventLoop","permalink":"http://liop.github.io/tags/EventLoop/"},{"name":"RunLoop","slug":"RunLoop","permalink":"http://liop.github.io/tags/RunLoop/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://liop.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"iOS 13 版本适配","date":"2020-04-03T08:23:48.000Z","path":"2020/04/03/iOS13-adaptive/","text":"1、新建的项目启动黑屏或者window不存在因为 iOS 13 下默认通过UISceneDelegate来管理窗口生命周期需要在AppleDelegate.h中添加window: @perperty (strong,nonatomic) UIWindow *window; 在AppleDelegate.m 中添加 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; if (@available(iOS 13.0, *)) &#123; // iOS 13 去 SceneDelegate 处理中了 &#125; else &#123; self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds]; self.window.rootViewController = [ContainerViewController shareInstance]; [self.window makeKeyAndVisible]; &#125; return YES;&#125; 2、一些私有属性已经不存在了，访问会crash UITextField 的 _placeholderLabel.textColor UITextField 的 _placeholderLabel.font UISearchBar 的 _cancelButton [UIApplication sharedApplication] 的 statusBarWindow 需要去掉或者重新实现，比如 // iOS 13下会crash[textfiled setValue:color forKeyPath:@&quot;_placeholderLabel.textColor&quot;];[textfiled setValue:font forKeyPath:@&quot;_placeholderLabel.font&quot;];// 替换为textfiled.attributedPlaceholder = xxx; 3、模态视图控制器切换不完全iOS 13 控制器的modalPresentationStyle被默认设置为 UIModalPresentationAutomatic解决方案： 如果像使用这个默认系统模式的话，可能需要适配页面。 修改视图控制器的 modalPresentationStyle 4、NSObjectNotAvailableException一些类以前被标记为 API_DEPRECATED 被移除了，需要使用新类 MPMoviePlayerController &#x3D;&gt; AVPlayerViewController UISearchDisplayController &#x3D;&gt; UISearchController UIAlertView &#x3D;&gt; UIAlertController 5、一些API 被弃用弃用 LaunchImage，使用 LaunchScreen.storyboard，不然没法提交审核弃用 UIWebView，使用WKWebView 6、一些权限变化 蓝牙权限描述：弃用 NSBluetoothPeripheralUsageDescription新增 NSBuletoothAlwaysUsageDescription如果支持iOS 13以前版本的话，两个都要 获取WIFI的SSID和BSSID：iOS 13 需要先开启 Access WiFi Information capability 7、使用第三方登录的问题如果集成了第三方登录，就需要提供 Sign in with Apple如果没集成第三方登录，就不用提供 8、NSData descriptioniOS 13 之前可以通过description 方法将data 转化为stringiOS 13 以后需要通过 - (NSString *)hexadecimalString: (NSData *)data &#123; const unsigned char *dataBuffer = (const unsigned char *)[data bytes]; if (!dataBuffer) &#123; return [NSString string]; &#125; NSUInteger dataLength = [data length]; NSMutableString *hexString = [NSMutableString stringWithCapacity:(dataLength * 2)]; for (int i = 0; i &lt; dataLength; ++i) &#123; [hexString appendFormat:@&quot;%02x&quot;, (unsigned int)dataBuffer[i]]; &#125; return [NSString stringWithString:hexString];&#125; 这个可能影响加解密和远程通知的TOKEN 获取 9、暗黑模式暂时不适配的处理： // 修改代码if (@available(iOS 13.0, *)) &#123; [UIApplication sharedApplication].keyWindow.overrideUserInterfaceStyle = UIUserInterfaceStyleLight;&#125;// 或者 修改info.plist&lt;key&gt;UIUserInterfaceStyle&lt;/key&gt;&lt;string&gt;Light&lt;/string&gt; 适配的处理：系统方案查看 UIColor+UIColorNameColors 和 UIColor+DynamicColors参考：腾讯的：使用 QMUITheme 实现换肤并适配 iOS 13 Dark Mode百度的：百度APP iOS暗黑模式适配的完美解决方案 参考资料 《iOS13的特性和适配》","tags":[{"name":"适配","slug":"适配","permalink":"http://liop.github.io/tags/%E9%80%82%E9%85%8D/"},{"name":"iOS 13","slug":"iOS-13","permalink":"http://liop.github.io/tags/iOS-13/"}],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://liop.github.io/categories/iOS/"}]},{"title":"iOS SDK 版本新特性","date":"2020-03-25T06:07:17.000Z","path":"2020/03/25/iOS-diff/","text":"iOS 13 新特性 深色模式 – 自动将 iOS 控件变成暗色调方案 SwiftUI – 全新的框架，Swift声明式编程方法写UI 多个UI实例 – 一个APP多窗口 SFSymbols – 支持和提供SVG格式矢量图标库，大概1500个内置图标 将您的 iPad App 带入 Mac – xcode提供选项，支持iPadAPP 迁移到MAc AR 增强 ARKit 3 – 随着设备的升级，功能进一步加强 RealityKit – 和AR配合，提供渲染、相机特效 Reality Composer – 快速制作AR内容原型 通过Apple登录 – 提供AppleiD登录，并强制APP提供 后台任务 – 全新的 BackgroundTasks 框架，提供几分钟的后台时间 相机拍摄 – 同时使用前后相机拍摄 Combine – 全新的框架，声明式SwiftAPI，适合MVVM Core Haptics – 全新的触控反馈框架 Apple CryptoKit – 全新的加密框架 MetricKit – 全新的性能监控采集框架 PencilKit – 全新的框架，提供手绘的绘图的环境，支持pencil和手指 Core ML 3 – 加强，支持设备端模型个性化 机器视觉 – 加强，支持检测识别图像的能力 VisionKit – 全新的框架，支持扫描文稿 Metal – 加强 CoreData – 加强，支持与CloudKit 配合 Core NFC – 加强，支持标签写入，更多协议 SiriKit – 加强，支持日程和控制音视频 iOS 12 ARKit 2 加强 多用户共享AR 对象检测 Siri 捷径 app支持短语 健康记录 HealthKit 新增 通知控件 支持交互 Pencil 加强 自动填充密码、验证码 CarPlay 车载框架 新增底层网络框架 Network ，支持 TCP、UDP、TLS等 新 Natural Language 框架 弃用 OpenGL ES，使用Metal 替代 iOS 11 ARKit 新增 CoreML 新增 iOS10 iMessage Apps User Notifications SirKit 更多的 Extensions iOS 9 UIStackView 新增 3D touch 新增 ContactFramework 新增 iOS8 Extensions Swift WKWebview 新增 CallKit Size Class Touch ID Photos.framework 新增 Self Sizing Cells iOS 7 UIKit Dynamics 自定义ViewController切换 iOS 6 Autolayout 参考链接[iOS SDK 的新功能]:https://developer.apple.com/cn/ios/whats-new/","tags":[{"name":"iOS SDK","slug":"iOS-SDK","permalink":"http://liop.github.io/tags/iOS-SDK/"},{"name":"适配","slug":"适配","permalink":"http://liop.github.io/tags/%E9%80%82%E9%85%8D/"}],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://liop.github.io/categories/iOS/"}]},{"title":"大厂app","date":"2020-03-23T08:28:08.000Z","path":"2020/03/23/大厂app/","text":"大厂流行APP梳理一下大厂的APP 百度系 百度 百度贴吧 爱奇艺 百度网盘 百度地图 百度知道 百度文库 阿里系 支付宝 淘宝 钉钉 闲鱼 天猫 优酷 书旗 夸克 虾米音乐 UC 浏览器 高德地图 企鹅系 微信 微信阅读 微信企业版 QQ QQ音乐 QQ浏览器 腾讯视频 腾讯新闻 腾讯手机管家 腾讯应用宝 腾讯自选股 头条系 今日头条 抖音短视频 faceu激萌 飞书、飞聊 火山小视频 悟空问答 西瓜视频 懂车帝 轻颜相机 皮皮虾 内涵段子","tags":[{"name":"app","slug":"app","permalink":"http://liop.github.io/tags/app/"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://liop.github.io/categories/%E9%9A%8F%E7%AC%94/"}]},{"title":"iOS APP 启动完成过程","date":"2020-03-10T07:09:41.000Z","path":"2020/03/10/iOS-APP-launch-process/","text":"1. 解析 info.plist这块没有 加载启动页 建立沙箱，检查权限 2. Mach-O 加载 或者说是 dyld加载流程 设置运行环境，环境变量，获取当前运行架构 加载共享缓存 加载主执行文件，生成一个imageLoader实例 加载所有插入的库 link 主执行文件 (link过程会先loadLibraries ，定位内部（rebase）、外部（bind）制作引用，比如 字符串、函数) link动态库 notify（dyld_image_state_bound） &#x3D;&gt; 触发 sNotifyObjCMapped绑定 objc库中map_images() map_image -&gt; map_images_nolock 计算 class selector 的数目 关键函数 _read_images fix selector map class protocal @protocal cattegry 执行弱符号绑定 关键函数调用 initializeMainExecutable() dependentImage-&gt;recursiveInitialization notify(dyld_image_state_dependents_initialized) &#x3D;&gt; 触发sNotifyObjCInit绑定的 objc中的load_images（） 执行所有的 +load 函数 当前image -&gt; doInitialization &#x3D;&gt; 会执行 attribute((constructor)) c函数 查找入口点并返回 main() 地址 程序执行 main &#x3D;&gt; UIApplicationMain &#x3D;&gt; Appdelegate","tags":[{"name":"iOS","slug":"iOS","permalink":"http://liop.github.io/tags/iOS/"},{"name":"面试","slug":"面试","permalink":"http://liop.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"启动","slug":"启动","permalink":"http://liop.github.io/tags/%E5%90%AF%E5%8A%A8/"}],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://liop.github.io/categories/iOS/"}]},{"title":"部署hexo+next 到github page 的一些坑","date":"2020-01-14T08:12:02.000Z","path":"2020/01/14/hexo-next-githubpage/","text":"打算把之前写的技术文档整理一下，先花了点时间布了 hexo + next 到github pages 上，同时用 travis 做自动发布，这里记录下遇到的问题。 Travis-CI 配置 .travis.yaml 文件主要参考这里，但这篇文章的是将生成的文字放到了gh-pages分支，但是对应个人博客而言，github pages 只能从master分支发布，参考了评论，合适的配置应该是这样的： sudo: falselanguage: node_jsnode_js: - 10 # use nodejs v10 LTScache: npmbranches: only: - hexo # 这里不能是master，master放 `hexo generate`之后 /public 中生成的内容script: - hexo generate # generate static filesdeploy: provider: pages skip-cleanup: true github-token: $GH_TOKEN keep-history: false # 如果你前面已经把代码推到仓库的master分支，这里可以强制覆盖 on: # 这是部署的条件 all_branches: true # 判断发生build的分支，是所有分支都可以部署 target_branch: master # 部署到的分支，个人现在是只能master分支 local-dir: public 使用 theme&#x2F;next 作为主题前面走了很多弯路，直接将 theme&#x2F;next加博客的仓库中，后面travis编译的适合提示 ‘layout’ 不存在，因为 thmem&#x2F;next 从github拉下来是有自己单独的仓库管理的。正确的步骤应该是： fork theme-next&#x2F;hexo-theme-next git pull ‘https://github.com/&lt;你的用户名&gt;&#x2F;hexo-theme-next.git’ theme&#x2F;next 到 theme&#x2F;next中，修改 _config.yml 文件, 并保存提交到git 通过 git submodule add https://github.com/&#x2F;hexo-theme-next.git theme&#x2F;next 到 xx.github.io 中，保存提交git 这样之后 travis 在编译的时，会自动init submodule 拉起子库代码,就不会出现缺文件的情况。同时需要注意下，git submodule add 的时候，仓库地址要用https的，不能走ssh通道，不然 travis 拉取 submodule 时会提示： Please make sure you have the correct access rights and the repository exists.fatal: clone of &#x27;git@github.com:liop/hexo-theme-next.git&#x27; into submodule path &#x27;/home/travis/build/liop/liop.github.io/themes/next&#x27; failedFailed to clone &#x27;themes/next&#x27;. Retry scheduledCloning into &#x27;/home/travis/build/liop/liop.github.io/themes/next&#x27;...Permission denied (publickey).fatal: Could not read from remote repository. next 配置语言hexo 默认是英文，需要修改为： language: zh-CN , ‘zh-CN’ 对应 theme&#x2F;next&#x2F;language 文件夹中的 zh-CN.yml，一些文章说的配置 ‘zh-Hans’ 不起作用是因为theme&#x2F;next&#x2F;language 下不存在 zh-Hans.yml 。 TODO：接下来将之前的文章迁移过来，遇到问题再记录","tags":[{"name":"web","slug":"web","permalink":"http://liop.github.io/tags/web/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://liop.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Shadow DOM!","date":"2017-02-11T03:36:33.000Z","path":"2017/02/11/2017-02-07-Shadow-DOM/","text":"Shadow DOM封装web组件的方案由shdow host 、shadow root、shdow contents 组成，shadow root 对用户不可见 实例 模板 &lt;template id=&quot;component-template&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .outer &#123; background-color: lightgrey; padding: 5px; &#125; .inner &#123; margin: 0 auto; &#125; &lt;/style&gt; &lt;div class=&quot;outer&quot;&gt; &lt;p&gt;sdsdsdsd&lt;/p&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; shadow host 容器 &lt;div id=&quot;container&quot;&gt;Container&lt;/div&gt; 将shadow contents 加载到容器下 // 创建 shadow Rootvar shadow = document.querySelector(&#x27;#container&#x27;).webkitCreateShadowRoot();// shadow hostvar component = document.querySelector(&#x27;#component-template&#x27;);// add to shadow hostshadow.appendChild(component.content);component.remove();","tags":[{"name":"web DOM","slug":"web-DOM","permalink":"http://liop.github.io/tags/web-DOM/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://liop.github.io/categories/%E5%89%8D%E7%AB%AF/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://liop.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"iOS","slug":"iOS","permalink":"http://liop.github.io/categories/iOS/"},{"name":"随笔","slug":"随笔","permalink":"http://liop.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"iOS 强制调试","slug":"iOS-强制调试","permalink":"http://liop.github.io/tags/iOS-%E5%BC%BA%E5%88%B6%E8%B0%83%E8%AF%95/"},{"name":"安卓 强制调试","slug":"安卓-强制调试","permalink":"http://liop.github.io/tags/%E5%AE%89%E5%8D%93-%E5%BC%BA%E5%88%B6%E8%B0%83%E8%AF%95/"},{"name":"技巧","slug":"技巧","permalink":"http://liop.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"生命周期","slug":"生命周期","permalink":"http://liop.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"前端缓存","slug":"前端缓存","permalink":"http://liop.github.io/tags/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/"},{"name":"性能优化","slug":"性能优化","permalink":"http://liop.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"错误监控","slug":"错误监控","permalink":"http://liop.github.io/tags/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/"},{"name":"EventLoop","slug":"EventLoop","permalink":"http://liop.github.io/tags/EventLoop/"},{"name":"RunLoop","slug":"RunLoop","permalink":"http://liop.github.io/tags/RunLoop/"},{"name":"适配","slug":"适配","permalink":"http://liop.github.io/tags/%E9%80%82%E9%85%8D/"},{"name":"iOS 13","slug":"iOS-13","permalink":"http://liop.github.io/tags/iOS-13/"},{"name":"iOS SDK","slug":"iOS-SDK","permalink":"http://liop.github.io/tags/iOS-SDK/"},{"name":"app","slug":"app","permalink":"http://liop.github.io/tags/app/"},{"name":"iOS","slug":"iOS","permalink":"http://liop.github.io/tags/iOS/"},{"name":"面试","slug":"面试","permalink":"http://liop.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"启动","slug":"启动","permalink":"http://liop.github.io/tags/%E5%90%AF%E5%8A%A8/"},{"name":"web","slug":"web","permalink":"http://liop.github.io/tags/web/"},{"name":"web DOM","slug":"web-DOM","permalink":"http://liop.github.io/tags/web-DOM/"}]}